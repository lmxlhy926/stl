//
// Created by lhy on 2020/12/18.
//

#ifndef STL_MTHREAD_H
#define STL_MTHREAD_H

/*
 * 现代化体系结构通常支持同时执行多个任务和多个线程, 如果采用多处理器内核,那么程序执行时间可在多线程情况下获得大幅改善.
 *
 * 并行带来的挑战:
 *      不再是完成一个语句后执行另一语句,而是多语句同时执行,于是可能导致并发访问同一资源
 *      造成创建,读取,涂写,删除等动作不在预期次序下发生,形成不可测的结果
 *
 * c++11不论语言自身或标准库都得到强化,可支持并发编程.
 * 标准库的支持包括: 启动多线程, 传递实参, 返回结果数值, 跨线程边界传递异常, 同步化等
 *
 * 组织结构:
 *      多线程启动方法
 *      线程的同步化
 *          Mutex, lock               独占访问共享资源
 *          condition variable        同步线程次序
 *          Atomic
 *      *多个线程同时运行可能会导致数据的并发访问, 同步化就是解决数据并发访问时可能引发的问题
 */


/*
 * 让程序更快速的一般性做法:
 *      使之受益于并行处理(如果低层平台对此有所支持), 但仍能够在单线程环境中正确运作.
 *
 * 线程中发生的异常:
 *      异常会终止线程, 因为它未被捕获.
 *      future object会保持这一状态直到get()被调用. 搭配get()后这个异常在main()内被进一步传播
 *      欲处理后台操作所生的异常, 只需偕同get()作出"以同步方式调用该操作"所作的相同动作即可.
 *
 * async():
 *      让一段机能(a piece of functionality)或说一个callable object若是可能的话在后台运行,成为一个独立线程
 *      尝试将其所获得的函数立刻异步启动于一个分离线程内
 *
 * class future<>: 允许你等待线程结束并取得其结果(一个返回值或是一个异常)
 *
 * future<>::get():
 *      如果函数被启动于一个分离线程中并且已结束, 立刻获得其结果
 *      如果函数被启动于分离线程中但是尚未结束, get()会引发停滞直到函数执行完并产生结果为止
 *      如果函数尚未启动, 函数会被强迫启动如同一个同步调用, get()会引发停滞直到产生结果.
 *      只能调用一次, 调用之后future就处于无效状态, 除了valid()和析构外,对它的任何调用都会导致不可预期的行为
 *
 * std::launch::async:
 *      有了async发射策略, 就不必非要调用get()了.
 *      当离开返回的future object作用域时,程序会阻塞等待后台任务结束
 *      如果不将async(std::launch::async, ...)的结果赋值出去,调用者会在此停滞到目标函数结束, 相当于一个同步调用.
 *      如何异步调用在此处无法实现,程序会抛出一个system_error异常.
 *
 * std::launch::deferred:
 *      保证函数绝不会在没有get()或wait()的情况下启动
 *      此策略的用处在于缓式求值
 *
 * future<>::wait():
 *      对某个future调用wait(), 会强制启动该future象征的线程并阻塞等待这一后台操作终止.
 *      等待后台操作完成而不需要处理其结果, 可被调用一次以上.
 *
 * future<>::wait_for(), future<>::wait_until(): 检查线程的运行状态, 返回以下3种状态
 *      std::future_status::deferred: 线程未启动
 *      std::future_status::timeout: 线程启动但是未结束
 *      std::future_status::ready: 线程已结束
 *
 */


/*
 * 传递实参
 *      如果以by reference方式传递实参, 被传递值甚至可能在后台任务启动前就变得无效.
 *      如果在一个线程中改动c, 在另一个线程中读取c, 这是对同一对象的异步并发处理, 将导致不可预期的行为, 除非使用mutex或atomic保护并发处理动作.
 *      如果使用async(), 就因该尽可能以by value方式传递实参, 使async()只需使用局部拷贝.使用引用时尽可能使用const reference, 且不使用mutable.
 */

namespace mthread{

    void test();

    void test1();

    void test2();

    void test3();
}




















#endif //STL_MTHREAD_H
