1. 什么是协议
	从应用的角度出发，协议可以理解为规则，是数据传输和数据解释的规则。
	双方都按此规则发送、接收数据。A和B之间达成的这个相互遵守的规则即为协议。

2. 典型协议
	应用层：		HTTP协议，FTP协议
	传输层：		TCP/UDP协议
	网络层：		IP协议、ICMP协议、IGMP协议
	网络接口层：	ARP协议、RARP协议
	
链路层：负责网卡设备的驱动、帧同步、冲突检测、数据差错校验等工作

虽然ARP、RARP、IP数据报都需要以太网驱动程序来封装成帧，但是从功能上划分，ARP、RARP属于链路层协议，IP属于网络层协议。虽然ICMP、IGMP、TCP、UDP的数据报都需要IP协议来封装成数据报，但是从功能上划分，ICMP、IGMP、IP同属于网络层，TCP、UDP属于传输层。


网络传输设备：
交换机：工作在链路层，可以在不同的链路层网络中间转发数据帧(比如十兆以太网和百兆以太网之间，以太网和令牌环网之间)，由于不同的链路层的帧格式不同，交换机要将进来的数据包拆掉链路层首部重新封装之后再转发。

路由器：工作在网络层的设备，根据IP地址选择合适的路径转发数据包，数据包从Internet上的源主机到目的主机往往要经过十多个路由器。同时兼有交换机的功能，可以在不同的链路层接口之间转发数据包，因此路由器需要将进来的数据包拆掉网络层和链路层2层首部并重新封装。



数据包封装：
	传输层及其以下的机制由内核提供，应用层由用户进程提供。
	应用层对通信数据的含义进行解释，而传输层及其以下处理通讯的细节。
	应用层数据通过协议栈发送到网络上时，每层协议都要加上一个数据首部，称为封装。
不同协议层对数据包有不同的称谓，在传输层叫段(segment)，在网络层叫做数据包(datagram)，在链路层叫做帧(frame)。数据封装成帧后发送到传输介质上，到达目的主机后每层协议再剥掉相应的首部，最后将应用层数据交给应用程序处理


以太网帧格式：
	| 目的Mac地址 | 源Mac地址 | 帧类型 | 数据 |

	地址：	指的是网卡的硬件地址（也叫MAC地址），长度是48位，在网卡出厂时固化。
	帧类型：有3种值，分别对应IP，ARP，RARP。
	MTU：以太网的最大传输单元为1500，不同网络类型有不同的MTU。如果一个数据包从以太网路由到拨号链路上，数据包长度大于拨号链路的MTU，则需要对数据包进行分片。MTU指的是数据帧中有效载荷的最大长度，不包括帧头长度。

ARP帧格式：
	在网络通信时，源主机的应用程序知道目的主机的IP地址和端口号，却不知道目的主机的硬件地址，而数据包首先是被网卡接收到然后再去处理上层协议的，如果接收到的数据包的硬件地址与本机不符，则直接丢弃。因此在通信前必须获得目的主机的硬件地址。ARP协议就起这个作用。源主机发起ARP请求，询问对应IP地址的主机的硬件地址是多少，并将这个请求广播到本地网段(以太网帧首部的硬件地址填FF:FF:FF:FF:FF:FF表示广播)，目的主机接收到广播的ARP请求，发现其中的IP地址和本机相符，则发送一个ARP应答数据包给源主机，将自己的硬件地址填写到应答包中。

	以太网首部：指定目的MAC地址、源MAC地址、帧类型（ARP、RARP、IP）
	ARP报文：
		硬件类型：指定链路层网络类型（以太网、令牌环网、拨号链路网）
		协议类型：指定要转换的地址类型（IP）
		地址长度：指定硬件地址长度，协议地址长度
		OP：指定是ARP请求还是ARP应答


IP数据报：A主机--->B主机
	指定版本、首部长度、指导路由路径选择原则、报文总长度
	用于数据报的分片和重组（数据报文长度超过MTU，会导致报文被分片，分片后需要重新组合）
	指定路由转发的最大跳数、上层协议类型（TCP、UDP、ICMP、IGMP）
	指定源IP地址、目的IP地址


UDP数据报：指定端口号，数据校验
	源端口号、目的端口号
	报文长度（首部 + 数据），报文校验和（首部 + 数据）
	
	每次运行客户端程序时，系统自动分配一个空闲的端口号，用完释放掉，称为ephemeral端口号。
	发送端UDP协议层只管把应用层传来的数据封装成段交给IP协议层就算完成任务了，如果因为网络故障该段无法发到对方，UDP协议层也不会给应用层返回任何错误信息。
	
	接收端的UDP协议层只管把接收到的数据根据端口号交给相应的应用程序就算完成任务了。

UDP可能导致的问题：等待应答、超时重发、为数据包编号、流量控制等
	数据包乱序：数据包在网络上传播时，经过不同的路由，可能导致接收顺序和发送顺序不同。
	流量控制：通常接收端的UDP协议层将接收到的数据放在一个固定大小的缓冲区中，等待应用程序来提取和处理。如果应用程序提取和处理的速度很慢，而发送端发送的速度很快，就会丢失数据包，UDP协议层并不报告这种错误。
	
TCP数据报格式
		源端口号、目的端口号
		报文序号、报文确认序号
		报文控制位（指明报文目的）、窗口大小（标识接收缓冲区，同步发送速率）
		校验和
	
三次握手：
		1. 客户端请求：SYN位置1标识连接请求，序号指明客户端初始确认序号
		2. 服务端回复：ACK置1并回复确认序号，SYN置1标识请求连接，序号指明服务端初始确认号
		3. 客户端回复：ACK置1标识收到
		客户端和服务端分别给对方发送了连接请求，也应答了对方的连接请求。其中服务器的请求和应答在一个段中发出。在建立连接的同时，双方协定了发送序号的初始值、段尺寸等。
	
	在数据的传输过程中，序号和确认序号是非常重要的。应用程序交给TCP协议发送的数据会暂存在TCP层的发送缓冲区中，发送数据包给对方后，只有收到对方应答的ACK段才知道数据包确实发送到了对方，可以从发送缓冲区中释放掉了，如果因为网络故障丢失了数据或者丢失了对方发回的ACK段，经过等待超时后TCP协议自动将发送缓冲区中的数据包重发。
	
关闭连接（四次握手）过程：
	由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。
	
滑动窗口（TCP流量控制）
	如果发送端发送的速度较快，接收端接收到数据后处理的速度较慢，而接收缓冲区的大小是固定的，就会丢失数据。发送端根据窗口的大小知道接收端的缓冲区满了，因此停止发送数据。
	
	应用程序所看到的数据是一个整体，或说是一个流，在底层通信中这些数据可能被拆分成很多数据包来发送，但是一个数据包有多少字节对应用程序是不可见的，因此TCP协议是面向流的协议。而UDP是面向消息的协议，每个UDP都是一条消息，应用程序必须以消息为单位提取数据，不能一次提取任意字节的数据。
	
	
TCP状态转化：
	LISTEN：		标识服务器的某个SOCKET处于监听状态，可以接受连接请求。
	
	SYN_SENT:		标识客户端已经发送SYN报文
	
	SYN_RCVD:		标识服务器收到客户端的SYN报文。
	
	ESTABLISHED:	客户端发送SYN报文后，收到ACK。或服务端发送SYN报文后，收到ACK。	
	
	FIN_WAIT_1：	客户端或服务端在ESTABLISHED状态时，想主动关闭连接，想对方发送了FIN报文后，进入此状态。
	
	FIN_WAIT_2:		主动关闭连接的一方，发出FIN收到ACK后进入该状态。称之为半连接或半关闭状态，该状态下的SOCKET只能接收数据，不能发送数据。
	TIME_WAIT:		主动关闭连接的一方收到了对方的FIN报文，并发送出了ACK报文后进入此状态。等2MSL后即可进入CLOSED可用状态。。
	
	CLOSE_WAIT：	收到主动关闭方的FIN报文后，被动关闭方自动回复ACK报文给对方，此时进入CLOSE_WAIT状态。此时等待被动关闭方调用close(fd)。
	
	LAST_ACK：		被动关闭方调用close(fd)发送FIN报文后进入此状态，当收到ACK回复时，即可进入CLOSED可用状态。
	
半关闭：
	使用close关闭一个连接，它只是减少描述符的引用计数，并不直接关闭连接，只有当描述符的引用计数为0时才关闭连接。
	使用shutdown不考虑描述符的引用计数，直接关闭描述符。
	
	
TIME_WAIT状态：
	1. 主动关闭方收到被动关闭方发送的FIN报文后进入的状态，即双方都调用了close(fd)。
	
	Lost duplicate：发出的数据包在规定时间内没有收到ACK确认。超时机制会导致相同报文被再次发送。因此接收端有可能收到2份该报文。
	
	Incarnation connection：指和上次socket pair一模一样的新连接。即连接关闭后，有创建了一个相同的新连接。
	
	Incarnation connection + lost duplicate会对传输造成致命错误。一个Incarnation connection收到一个lost duplicate，则TCP有可能认为这个数据报合法，从而存储接收缓冲区中，导致传输出现错误。通过一个2MSL的等待时间，会使所有的lost duplicate都消失，避免对新连接造成错误。RFC要求socket pair在处于TIME_WAIT状态时，不能再起一个Incarnation connection。即在2MSL时间内，不能创建一个和之前相同的连接。这样就保证，即使收到lost duplicate也一定会拒绝该报文。RFC仅仅要求socket pair不一致，而实现中只要这个port处于TIME_WAIT就不允许起连接。可以通过给服务器的socket设置SO_REUSEADDR选项，这样的话即使熟知的端口处于TIME_WAIT状态，在这个端口上依旧可以将服务启动。即使使用了SO_REUSEADDR选项，但socket pair这个限制依旧存在。
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	