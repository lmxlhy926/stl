# 1.1 引言

所有操作系统都为它们所运行的程序提供服务。典型的服务包括：执行新程序、打开文件、读文件、分配存储区以及获得当前时间等。

# 1.2 unix体系结构

从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。我们通常将这种软件称为**内核（kernel)**，因为它相对较小，而且位于环境的核心。

**内核的接口被称为系统调用**。公用函数库构建在系统调用接口之上，应用程序即可使用公用函数库，也可使用系统调用。shell是一个特殊的应用程序，为运行其它应用程序提供一个接口。

从广义上说，操作系统包括了内核和一些其它软件，这些软件使得计算机能够发挥作用，并使计算机具有自己的特性。这里所说的其它软件包括**系统实用程序、应用程序、shell、以及公用函数库**等。

# 1.3 登录

用户在登录unix系统时，先键入登录名，然后键入口令。系统在其口令文件中（通常是/etc/passwd）中查看登录名。口令文件中的登录项由7个以冒号分隔的字段组成，依次是：登录名、加密口令、数字用户ID、数字组ID、注释字段、**`起始目录以及shell程序`**。目前，所有的系统已将加密口令移动到另一个文件中。

shell是一个命令行解释器，它读取用户输入，然后执行命令。shell的用户输入通常来自于终端（交互式shell），有时则来自于文件（称为shell脚本）

# 1.4 文件和目录

## **文件系统**

**unix文件系统是目录和文件的一种层次结构**，所有东西的起点是称为根（root）的目录，这个目录的名称是一个字符"/"。目录是一个包含目录项的文件。**在逻辑上，可以认为每个目录项都包含一个文件名，同时还包含说明该文件属性的信息**。文件属性是指：文件类型、文件大小、文件所有者、文件权限、以及文件最后的修改时间等。

## **文件名**

目录中的各个名字称为文件名（filename）。只有斜线和空字符这2个字符不能出现在文件名中。斜线用来分隔构成路径名的各个文件名，空字符则用来终止一个路径名。POSIX.1推荐将文件名限制在以下字符集内：字母（a~z、A~Z）、数字（0~9）、句点（.）、短横线（-）和下划线（_）

## **路径名**

由斜线分隔的一个或多个文件名组成的序列构成路径名，以斜线开头的路径名称为绝对路径，否则为相对路径名。相对路径名指向相对于当前目录的文件。

## **工作目录**

每个进程都有一个**`工作目录`**，有时称其为当前工作目录。所有相对路径名都从工作目录开始解释。

## **起始目录**

登录时，工作目录设置为**`起始目录`**。

# 1.5 输入和输出

## 文件描述符

文件描述符（file descriptor）通常是一个小的非负整数，内核用以标识一个特定进程正在访问的文件。当内核打开一个现有文件或者创建一个新文件时，它都返回一个文件描述符。

## 标准输入、标准输出、标准错误

按惯例，每当运行一个新程序时，所有的shell都为其打开3个文件描述符，即标准输入、标准输出、标准错误。如果不做特殊处理，则这3个描述符都链接向终端。大多数shell都提供一种方法，使其中任何一个或所有这3个描述符都能重新定向到某个文件。

## 不带缓冲的I/O

函数open、read、write、lseek以及close提供了不带缓冲的I/O。这些函数都使用文件描述符。

2个常量STDIN_FILENO、STDOUT_FILENO定义在<unistd.h>头文件中，它们指定了标准输入和标准输出的文件描述符符。在POSIX标准中，它们的值分别是0和1，但是考虑到可读 性，我们将使用这些名字来表示这些常量。

## 标准I/O

标准I/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的接口。使用标准I/O函数无需担心如何选取最佳的缓冲区大小。使用标准I/O函数还简化了对输入行的处理。标准I/O常量stdin、stdout也在头文件<stdio.h>中定义，它们分别表示标准输入和标准输出。

# 1.6 程序和进程

## 程序

程序是 一个存储在磁盘上某个目录中的可执行文件。内核使用exec函数，将程序读入内存，并执行程序。

## 进程和进程ID

程序的执行实例被称为进程。UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程ID。进程ID总是一个非负整数。getpid返回一个pid_t数据类型。我们不知道它的大小，仅知道的是标准会保证它能保存在一个长整型中。

## 进程控制

有3个用于进程控制的主要函数：fork、exec、waitpid。

在子进程中，调用execlp以执行从标准输入读入的指令。**这就用新的程序文件替换了子进程原先执行的程序文件**。fork和跟随其后的exec两者的组合就是某些操作系统所称的产生一个新进程。在UNIX系统中，这2部分分离成2个独立的函数。

## 线程和线程ID

通常，一个进程只有一个控制线程。对于某些问题，如果有多个控制线程分别作用于它的不同部分，那么解决起来就容易的多。另外，多个控制线程也可以充分利用多处理器系统的并行能力。

一个进程内的所有线程共享同一地址空间、文件描述符、栈、以及进程相关的属性。它们能访问同一存储区，所以各线程在访问共享数据时采取同步措施以避免不一致性。

与进程相同，线程也用ID标识。但是，线程ID只在它所属的进程内起作用。一个进程中的线程ID在另一个进程中没有意义。

控制线程的函数和控制进程的函数类似，但另有一套。线程模型是在进程模型建立很久后才被引入到UNIX系统中的，然而这2种模型之间存在复杂的交互。

# 1.7 出错处理

当UNIX系统函数出错时，通常会返回一个负值，而且整型变量errno通常被设置为具有特定信息的值。文件<errno.h>中定义了errno以及可以赋予它的各种常量。POSIX和ISO C将errno定义为一个符号，它扩展成为一个可修改的整型左值。它可以是一个包含出错编号的整数，也可以是一个返回出错编号指针的函数。

在支持线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部errno以避免一个线程干扰另一个线程。linux支持多线程存取errno。

**出错恢复**

可将在<errno.h>中定义的各种出错分成2类：致命性和非致命性。对于致命性的错误，无法执行恢复动作。最多能做的是在用户屏幕上打印一条出错信息或将一条出错信息写入日志文件中，然后退出。大多数非致命性的错误是暂时的（如资源短缺），当系统中的活动较少时，这种出错很可能不会发生。对于资源相关的非致命性错误的典型操作是延迟一段时间，然后重试。

# 1.8 用户标识

## 用户ID

口令文件登录项中的用户ID是一个数值，它向系统标识各个不同的用户。**系统管理员在确定一个用户的登录名的同时，确定其用户ID**。通常每个用户有一个唯一的用户ID。内核使用用户ID来检验该用户是否有执行某些操作的权限。用户ID为0的用户为根用户或超级用户。在口令文件中，通常有一个登录项，其登录名为root，我们称这种用户的特权为超级用户特权。

**组ID**

口令文件登录项也包括用户的组ID，它是一个数值。**组ID也是系统管理员在指定用户的登录名时分配的**。组被用于将若干用户集合到项目或部门中去。这种机制允许同组的各个成员之间共享资源。

**附属组ID**

除了在口令文件中对一个登录名指定一个组ID外，大多数UNIX系统版本还允许一个用户属于另外一些组。POSIX要求系统至少应支持8个附属组。

# 1.9 信号

信号用于通知进程发生了某种情况。进程有以下3种处理信号的方式：

1. 忽略信号
2. 按系统默认方式处理
3. 提供一个函数，信号发生时调用该函数，这被称为捕捉该信号。通过提供自编的函数，我们就能知道什么时候产生了信号，并按期望的方式处理它。

终端上有2种产生信号的方法，分别被称为中断键和退出键，它们被用于中断当前运行的进程。另一个产生信号的方法是调用kill函数。在一个进程中调用此函数就可向另一个进程发送一个信号。当然这样做也有些限制：当向一个进程发送信号时，我们必须是那个进程的所有者或者是超级用户。

# 1.10 时间值

**日历时间**

该值是自协调世界时（UTC）1970年1月1日00::00::00这个特定时间以来所经过的秒数累计值。系统基本数据类型time_t用于保存这种时间值。

**进程时间**

也被称为CPU时间，用以度量进程使用的中央处理器资源。**进程时间以时钟滴答计算**。每秒钟曾经取为50、60或100个时钟滴答。**系统基本数据类型clock_t保存这种时间值**。当度量一个进程的执行时间时，UNIX系统为一个进程维护了3个进程时间值：

- 时钟时间
- 用户CPU时间
- 系统CPU时间

**时钟时间**：又被称为墙上时钟时间，它是进程运行的时间总量，其值与系统中同时运行的进程数有关。

**用户CPU时间**：执行用户指令所用的时间量。

**系统CPU时间**：进程执行内核程序所经历的时间。

用户CPU时间和系统CPU时间之和常被称为CPU时间。

# 1.11 系统调用和库函数

所有的操作系统都提供了多种服务的入口点，由此程序向内核请求服务。各种版本的UNIX实现都提供了良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用（system call）。Linux 3.2.0提供了380多个系统调用。

本书中，系统调用和库函数都以C函数的形式出现，两者都为应用程序提供服务。但是，我们应当了解，如果希望的话，我们可以替换库函数，但是系统调用通常是不能被替换的。应用程序既可以调用系统调用也可以调用库函数。很多库函数则会调用系统调用。









