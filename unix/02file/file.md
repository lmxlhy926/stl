# 文件I/O

## 引言

UNIX系统中的大多数文件I/O只需用到5个函数：`open`, `read`, `write`, `lseek`, `close`。

本章描述的函数经常被称为**`不带缓冲的I/O`**，与**`标准I/O函数`**相对照。术语不带缓冲指的是每个`read`, `write` 都调用内核中的一个系统调用。

只要涉及在多个`进程间共享资源`，原子操作的概念就变的非常重要。本章将进一步讨论在多个进程间如何共享文件，以及所涉及的内核有关数据结构。在描述了这些特征后，将说明`dup`	`fcntl`	 `sync`	`fsync`	`ioctl`函数。

## 文件描述符

**对于内核而言，所有打开的文件都通过文件描述符引用**。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，**内核向进程返回一个文件描述符**。按照惯例，UNIX系统shell把文件描述符0与进程的标准输入关联，文件描述符1与进程的标准输出关联，文件描述2与进程的标准错误关联。在符合POSIX.1的应用程序中，幻数0、1、2虽然已被标准化，但应当把他们替换成符号常量**STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO**以提高可读性。

## open

```c
#include <fcntl.h>
int open(const char* path, int oflag, .../*mode_t mode*/)
					
参数说明：
    path：要打开或创建文件的名字，用绝对路径来指示。
    oflag：一个或多个常量进行"或"运算构成oflag参数。
    mode：仅当创建新文件时才使用这个参数，指明创建的文件的访问权限位
返回值：
	若成功返回文件描述符，若错误返回-1.
```

由open和openat函数返回的文件描述符一定是最小的未用描述符数值。

## close

```c
#include <unistd.h>
int close(int fd);
返回值：
    若成功返回0，若失败返回-1
```

关闭一个文件时还会释放该进程加在该文件上的所有记录锁。

当一个进程终止时，内核自动关闭它所有的打开文件。

## lseek

```c
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence)
    
whence取值:
    SEEK_SET：绝对偏移量
    SEEK_CUR：相对于当前位置的偏移量
    SEEK_END：相对文件尾端的偏移量
返回值：
    成功返回新的文件偏移量，出错返回-1
```

**每个打开文件都有一个与其相关联的"当前文件偏移量"**。它通常是一个非负整数，用来度量从文件开始处计算的字节数。**通常，读、写操作都从当前文件偏移量处开始，并使偏移量增加所读写的字节数**。对于普通文件，其偏移量必须是非负值。因为偏移量可能是负值，所以在比较lseek的返回值时需要谨慎，不要测试它是否小于0，而要测试它是否等于-1.

文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞，这一点是允许的。**位于文件中但是没有写过的字节都被读为0**。文件中的空洞并不要求在磁盘上占用存储区，具体处理方式和文件系统的实现有关。

因为lseek使用的偏移量是用off_t类型表示的，所以允许具体实现根据各自特定的平台自行选择大小合适的数据类型。现今大多数平台提供2组接口以处理文件偏移量。一组使用32位文件偏移量，另一组使用64位文件偏移量。尽管可以实现64位文件偏移量，但是能否创建一个大于2GB的文件则依赖于底层文件系统的类型。

## read

```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes);
返回值：
    读到的字节数，若已到文件尾端，返回0；若出错，返回-1
```

有多种情况可使实际读到的字节数小于要求读的字节数：

​		**读普通文件：**在读到要求字节数之前已经到达了文件尾端

​		**读终端设备：**通常一次最多读一行

​		**读网络：**网络中缓冲机制可能造成返回值小于所要求读的字节数

​		**读管道或FIFO：**管道包含的字节数小于所需的数量，返回实际可用的字节数

​		**读面向记录的设备：**如磁带，一次最多返回一个记录

​		**信号中断：**信号造成中断，而已经读取了部分数据量

## write

```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t nbytes);
返回值：
    若成功返回已写的字节数；若出错，返回-1
```

write出错的一个常见原因是磁盘已写满，或者超过了一个给定进程的文件长度限制。

对于普通文件，写操作从文件的当前偏移量处开始。如果在打开该文件时，指定了O_APPEND选项，则在每次写操作之前，将文件偏移量设置在文件的当前结尾处。在一次成功写之后，该文件偏移量增加实际写的字节数。



## 文件共享

**UNIX系统支持在不同的进程间共享打开文件**。

内核使用3种数据结构表示打开文件

* **打开文件描述符表**

  ​		文件描述符标志：`close_on_exec`

  ​		指向一个文件表项的指针

* **文件表项**

  ​		文件状态标志（读、写、添写、同步和非阻塞等）

  ​		当前文件偏移量

  ​		指向该文件v节点表项的指针

* **v节点表项**

  ​		文件类型、对此文件进行各种操作的函数的指针

  ​		i节点：文件所有者、**`文件长度`**、指向文件实际数据块在磁盘上所在位置的指针等

从UNIX系统的早期版本以来，这3张表之间的关系一直保存至今。这种关系对于在不同进程间共享文件的方式非常重要。



**如果2个独立的进程各自打开了同一个文件**

* 打开该文件的每个进程获得各自的一个文件表项，但是对于一个给定的文件只有一个v节点表项。之所以每个进程都获得自己的文件表项，是因为这可以使得每个进程都有它自己的对该文件的当前偏移量。

* 在完成每个write操作后，在文件表项中的当前文件偏移量即增加所写入的字节数。如果这导致当前文件偏移量超出了当前文件长度，则将i节点表项中的当前文件长度设置为当前文件偏移量，即该文件加长了。

* 如果用O_APPEND标志打开一个文件，则相应标志也被设置到文件表项的文件状态标志中。如果对这种具有追加写标志的文件执行写入操作时，文件表项中的当前文件偏移量首先会被设置为i节点表项中的文件长度。这就使得每次写入的数据都追加到文件的当前尾端处。该操作为原子操作

* lseek函数只修改文件表项中的当前文件偏移量，不进行任何I/O操作。

**多个文件描述符项指向同一文件表项**

* 使用dup函数
* 使用fork函数，此时父、子进程各自的每一个打开文件描述符共享同一个文件表项。



## 原子操作

多个进程写同一文件时，可能产生预想不到的结果。问题出现在逻辑操作"先定位到文件尾端，然后写"，它使用了2个分开的函数调用。**解决问题的方法是使这2个操作对于其它进程而言成为一个原子操作**。任何要求多于一个函数调用的操作都不是原子操作，因为在2个函数之间，内核有可能会临时挂起进程。

一般而言，原子操作指的是由多步组成的一个操作。如果该操作原子的执行，**要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集**。



## dup和dup2

```c
#include <unistd.h>
int dup(int fd);
int dup2(int fd, int fd2);
如果成功，返回新的文件描述符；如果出错，返回-1。
```

这2个函数用来复制一个现有的文件描述符。

对于dup2，可以使用fd2参数指定新描述符的值。如果fd2已经打开，则先将其关闭。如果fd等于fd2，则dup2返回fd2，而不关闭它。否则，fd2的`FD_CLOEXEC`文件描述符标志就被清除，这样fd2在进程调用exec时是打开状态。

这些函数返回的新文件描述符与参数fd共享同一个文件表项。



## 函数sync，fsync和fdatasync

传统的unix系统实现在内核中设有缓冲区高速缓存或页高速缓存，大多数磁盘I/O都通过缓冲区进行。**当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候再写入磁盘**。这种方式被称为延时写。通常，当内核需要重用缓冲区来存放其它磁盘块数据时，它会把所有延迟写数据块写入磁盘。为了保证磁盘上实际文件系统与缓冲区中内容的一致性，unix系统提供了sync，fsync，和fdatasync三个函数。

sync只是将**所有修改过的块缓冲区排入写队列**，然后就返回，它并不等待实际写磁盘操作结束。通常，称为update的系统守护进程周期性的调用sync函数。这就保证了定期冲洗内核的块缓冲区。

**fsync函数只对由文件描述符fd指定的一个文件起作用，并且等待写磁盘操作结束才返回**。fsync可用于数据库这样的应用程序，这种应用程序需要确保修改过的块立即写到磁盘上。



## fcntl

```c
#fcntl函数可以改变已经打开的文件的属性
#include <fcntl.h>
int fcntl(int fd, int cmd, ..../* int arg*/)
    返回值：若成功，则依赖于cmd；若出错，则返回-1.
```

在unix系统中，通常write只是将数据排入队列，而实际的写磁盘操作则可能在以后的某个时刻进行。而数据库系统则需要使用O_SYNC，这样一来，当它从write返回时就知道数据已确实写到了磁盘上，以免在系统异常时产生数据丢失。

在写磁盘文件时，系统时间增加了，其原因是内核需要从进程中复制数据，并将数据排入队列以便由磁盘驱动器将其写到磁盘上。当写至磁盘文件时，我们期望时钟时间也会增加。

在这种情况下，linux操作系统并不允许我们用fcntl设置O_SYNC标志，而是显示失败但是没有返回出错。但如果在文件打开时能指定该标志，我们还是应该遵重这个标志的。





























