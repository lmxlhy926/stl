
# 链接器
## 什么是链接
链接就是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载到内存并执行。


## 链接发生的时机
* **编译时**：即源代码被翻译为机器代码时。链接静态库时，采用该方式。

* **加载时**：程序被加载器加载到内存后、开始执行前。链接共享库时，可采用该方式。

* **运行时**：应用程序在用户代码中主动调用动态链接器接口，主动加载共享库。链接共享库时，可采用该方式。


## 链接带来的好处
**分离编译**：不用将一个大型的应用程序组织为一个巨大的源文件，而是可以将它分解为更小、更好管理的模块，可以独立的修改和编译这些模块。当我们改变这些模块中的一个时，只需简单的重新编译它，并重新链接应用，而不必重新编译其它文件。


## 链接器的2个主要任务
### 符号解析：
目标文件定义和引用符号，每个符号对应一个函数、一个全局变量或一个静态变量(即C语言中任何以static属性声明的变量)。**符号解析的目的是将每个符号引用正好和一个符号定义关联起来**。**链接器解析符号引用的方法是将每个引用与它输入的可重定位目标文件的==符号表中的一个确定的符号定义==关联起来**。对那些引用定义在相同模块中的局部符号的引用，符号解析是非常简单明了的。编译器只允许每个模块中每个局部符号只有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。不过，对全局符号的引用解析就棘手的多。当编译器遇到一个不是在当前模块中定义的符号(变量或函数名)时，会假设该符号是在其它某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。**如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就会输出一条错误信息并终止**。

在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描可重定位目标文件和存档文件。驱动程序自动将命令行中的.c文件翻译为.o文件。在这次扫描中，链接器维护一个可重定位目标文件的集合E(这个集合中的文件会被合并起来形成可执行文件)，一个未解析的符号(即引用了但是尚未定义的符号)集合U，以及一个在前面输入文件中已定义的符号集合D。初始时，E、U和D均为空。

* 对于命令行上的每个输入文件f，链接器会判断f是一个目标文件还是一个存档文件。如果f是一个目标文件，那么链接器把f添加到E，**修改U和D来反映f中的符号定义和引用**，并继续下一个输入文件。

* **如果f是一个存档文件，那么链接器就尝试匹配U中未解析的符号和由存档文件成员定义的符号**。**如果某个存档文件成员m，定义了一个符号来解析U中的一个引用，那么就将m添加到E中，并且链接器修改U和D来反映m中的符号定义和引用**。**对存档文件中所有的成员目标文件都依次进行这个过程，直到U和D不再发生变化**。**此时，任何不包含在E中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件**。

* 如果当链接器完成对命令行上输入文件的扫描后，U是非空的，那么链接器就会输出一个错误并终止。否则它会合并和重定位E中的目标文件，构造输出的可执行文件。

### 重定位：
编译器和汇编器生成从地址0开始的代码和数据节。**链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置**。链接器使用汇编器产生的重定位条目的详细指令，不加甄别地执行这样的重定位。一旦链接器完成了符号解析这一步，就把代码中的每个符号引用正好和一个符号定义(即它的一个输入目标模块中的一个符号表条目)关联起来。此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始重定位步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。重定位由2步组成：

* **重定位节和符号定义**。在这一步中，**链接器将所有相同类型的节合并为同一类型的新的聚合节**。例如，来自所有输入模块的.data节被全部合并成一个节，这个节成为输出的可执行目标文件的.data节。然后，**链接器将运行时内存地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号**。当这一步完成时，**程序中的每条指令和全局变量都有唯一的运行时内存地址了**。
* **重定位节中的符号引用**。在这一步中，**链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址**。要执行这一步，链接器依赖于可重定位目标模块中称为重定位条目的数据结构。

**目标文件纯粹是字节快的集合**。这些块中，有些包含程序代码，有些包含程序数据，而其它则包含引导链接器
和加载器的数据结构。**链接器将这些块连接起来，确定被连接块的运行时位置，并且修改代码和数据块中的各种位置**。链接器对目标机器了解甚少。产生目标文件的编译器和汇编器已经完成了大部分工作。



# 目标文件

## 目标文件的三种形式
### 可重定位目标文件
* 包含二进制代码和数据，其形式可以在编译时与其它可重定位目标文件合并起来，创建一个可执行文件。

### 共享目标文件    
* 一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

### 可执行目标文件  
* 包含二进制代码和数据，其形式可以被直接复制到内存并执行。

​	*目标文件是按照特定的目标文件格式组织的，各个系统的目标文件格式都不相同。*
​	*从贝尔实验室诞生的第一个Unix系统使用的是a.out格式。*
​	*Windows使用可移植可执行格式：Portable Executable, PE*
​	*现代x86-64 Linux 和 Unix系统使用可执行可链接格式：Executable and Linkable Format, ELF*



## *可重定位目标文件：*

### 文件格式

| 名称          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| **ELF头**     | 指明如下信息：系统字、字节顺序、ELF头大小、目标文件类型(可重定位、可共享、可执行)、机器类型(如x86-64)、**节头部表的文件偏移**、节头部表中条目的大小和数量。 |
| **.text**     | 已编译程序的机器代码                                         |
| **.rodata**   | 只读数据，如printf语句中的格式串和开关语句的跳转表           |
| **.data**     | 已初始化的全局和静态C变量                                    |
| **.bss**      | 未初始化或初始化为0的全局和静态C变量。目标文件的这个节不占据实际的磁盘空间，仅仅是一个占位符。运行时，在内存中分配这些变量，初始值为0 |
| **.symtab**   | 符号表，存放程序中定义和引用的函数和全局变量的信息。不包含局部变量的条目。 |
| **.rel.text** | 一个.text节中位置的列表，当链接器把这个目标文件和其它目标文件组合时，需要修改这些位置。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。 |
| **.rel.data** | 被模块引用或定义的所有全局变量的重定位信息。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量的地址或者外部定义函数的地址，都需要被修改。 |
| .debug        | 一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及**原始的C源文件**。以-g选项调用编译器驱动程序，才会生成。 |
| .line         | 原始C源程序中的行号和.text节中机器指令之间的映射。以-g选项调用编译器驱动程序，才会生成。 |
| **.strtab**   | 一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。字符串表就是以null结尾的字符串序列。 |
| **节头部表**  | 不同节的位置和大小是由节头部表描述的，其中目标文件中的每个节都有一个固定大小的条目 |

### 符号表

* 每个符号都被分配到目标文件的某个节，由section字段表示，该字段也是一个到节头部表的索引。

* 三个特殊的伪节，它们在节头部表中是没有条目的：

​		ABS：   	不该被重定位的符号
​    	**UNDEF**： 未定义的符号，也就是在本目标模块中引用，但是却在其它地方定义的符号；

```c
//ELF符号表条目
typedef struct{
    int name;			// 字符串表中的字符偏移，指明符号名称；
    char type:4,		// Function or data
    	 binding:4;		// Local or global
    char reserved;		// Unused
    short section;		// 节头部表偏移：指明定义符号的节的位置
    long value;			// 距定义目标的节的起始位置的偏移。
    long size;			// 目标的大小(以字节为单位)
}Elf64_Symbol;
```



### 重定位条目

当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，**无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用**。代码的重定位条目放在.rel.text中。已初始化数据的重定位条目放在.rel.data中。

```c
//重定位条目
typedef struct{
    long offset,	// 被修改的引用的节偏移
    long type:32,	// type:告知链接器如何修改新的引用；如32位PC相对地址，32位绝对地址引用。
    	 symbol:32;	// symbol:标识被修改的引用应该指向的符号
    long addend;
}Elf64_Real;
```



## 可执行目标文件

### 文件格式

| 名称     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| ELF头    | ELF头描述文件的总体格式。它还包括程序的入口点，也就是当程序运行时要执行的第一条指令的地址。 |
| 段头部表 | 将连续的文件节映射到运行时内存段                             |
| .init    | 定义了一个小函数，叫做_init，程序的初始化代码会调用它。      |
| .text    |                                                              |
| .rodata  |                                                              |
| .data    |                                                              |
| .bss     |                                                              |
| .symtab  |                                                              |
| .debug   |                                                              |
| .line    |                                                              |
| .strtab  |                                                              |
| 节头部表 |                                                              |

程序刚开始时是一组ASCII文本文件，现在已被转换为一个二进制文件，**且这个二进制文件包含加载程序到内存并运行它所需要的所有信息**。.text、.rodata和.data节与可重定位目标文件中的节是相似的，除了这些节已经被重定位到它们最终的运行时内存地址外。因为可执行文件是完全链接的(已被重定位)，所以它不再需要.rel节。**ELF可执行文件被设计的很容易加载到内存，可执行文件的连续的片被映射到连续的内存段。程序头部表描述了这种映射关系**。

### 加载执行

`prog`不是一个内置的shell命令，所以`shell`会认为`prog`是一个可执行目标文件，通过调用某个驻留在内存中称为加载器的操作系统代码来运行它。任何Linux程序都可以通过调用`execve`函数来调用加载器。**加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序**。这个将程序复制到内存并运行的过程叫做加载。**当加载器运行时，在程序头部表的引导下，加载器将可执行文件的片复制到代码段和数据段**。接下来，加载器跳转到程序的入口点，也就是`_start`函数的地址。这个函数是在系统目标文件ctrl.o中定义的，对所有的C程序都是一样的。`_start`函数调用系统启动函数`__libc_start_main`，该函数定义在libc.so中。**它初始化执行环境，调用用户层的`main`函数，处理main函数的返回值，并且在需要的时候把控制返回给内核**。

**加载器实际工作概述**：**Linux系统中每个程序都运行在一个进程上下文中，有自己的虚拟地址空间**。当shell运行一个程序时，父shell进程生成一个子进程，它是父进程的一个复制。**子进程通过execve系统调用启动加载器**。加载器删除子进程现有的虚拟内存段，并创建一组新的代码、数据、堆和栈端。新的栈和堆段被初始化为零。**通过将虚拟地址空间中的页映射到可执行文件的页大小的片，新的代码和数据段被初始化为可执行文件的内容**。最后加载器跳转到`_start`地址，它最终会调用应用程序的main函数。除了一些头部信息，在加载过程中没有任何从磁盘到内存的数据复制。直到CPU引用一个被映射的虚拟页时才会进行复制，此时，操作系统利用它的页面调度机制自动将页面从磁盘传送到内存。

## 可共享目标文件

共享库是致力于解决静态库缺陷的一个现代化创新产物。**共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为动态链接，是由一个叫做动态链接器的程序来执行的**。

共享库是以两种不同的方式来共享的。

* 对于一个库只有一个.so文件。所有引用该库的可执行目标文件共享这个.so文件中的代码和数据。
* 在内存中，一个共享库的.text节的一个副本可以被不同的正在运行的进程共享。

### 加载时链接

基本思路是当创建可执行文件时，静态执行一些链接，然后在程序加载时，动态完成链接过程。**可执行文件没有复制共享库的代码和数据节，反之，链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对.so中代码和数据的引用**。当加载器加载部分链接的可执行文件prog21时，它注意到prog21包含一个.interp节，这一节包含动态链接器的路径名，动态链接器本身就是一个共享目标(如在Linux系统上的ld-linux.so)。**加载器不会像它通常所做的那样将控制传递给应用，而是加载和运行这个动态连接器**。然后，动态链接器执行下面的重定位完成链接任务：       

* 重定位libc.so的文本和数据到某个内存段
* 重定位libvector.so的文本和数据到另一个内存段
* **重定位prog21中所有对由libc.so和libvector.so定义的符号的引用**。

**最后，动态链接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变**。

总结：

* .a文件和.so文件链接的机制不一样
  * 当引用的未定义符号在.a文件的相应成员文件中时，重定位成员文件的代码节和数据节，重定位对成员文件中符号的引用。**最终生成的是完全链接的可执行程序**。
  * 当引用的未定义符号在共享库中时，链接器并不复制共享库的代码和数据节，而只是复制了一些重定位和符号表信息。**最终生成的是部分链接的可执行程序**。

* 加载部分链接的可执行程序的步骤
  * 加载器首先加载部分链接的可执行程序
  * 加载器加载并运行动态链接器
  * 动态链接器首先重定位部分链接的可执行程序所引用的共享库—重定位共享库的代码节和数据节到某个内存段，然后重定位部分链接的可执行程序中对共享库定义的符号的引用，最后再将控制传递给应用程序。此时共享库的位置就固定了，并且在程序执行过程中都不会改变。此时程序变为了完全链接的可执行程序。
  * 执行完全链接的可执行应用程序

​		部分链接的可执行程序在运行之前(具体就是加载阶段)，必须先调用动态链接器完成对共享库的重定位，而后才能执行。动态链接器只有在

### 运行时链接

我们已经讨论了在**应用程序被加载后执行前时，动态链接器加载和链接共享库**的情景。然而，**应用程序还可能在它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中**。其思路是将每个生成动态内容的函数打包在共享库中。当一个来自web浏览器的请求到达时，服务器动态地加载和链接适当的函数，然后直接调用它，而不是使用fork和execve在子进程的上下文中运行函数。函数会一直缓存在服务器的地址空间中，所以只要一个简单的函数调用的开销就可以处理随后的请求了。这对一个繁忙的网站来说是有很大的影响的。更进一步地说，在运行时无需停止服务器，就可以更新已存在的函数，以及添加新的函数。

### 位置无关码

共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，因而节约宝贵的内存资源。**现代系统以这样一种方式编译共享模块的==代码段==，使得可以把它们加载到内存的任何位置而无需链接器修改**。使用这种方法，无限多个进程可以共享一个共享模块的代码段的单一副本。（当然，每个进程仍然会有它自己的读/写数据块）。**可以加载而无需重定位的代码称为位置无关代码**(Position-Independent Code, PIC)。**用户对GCC使用-fpic选项指示GNU编译系统生成PIC代码。共享库的编译必须总是使用该选项**。



**PIC中的数据引用**：代码段中任何指令和数据段中任何变量之间的距离都是一个运行时常量，与代码段和数据段的绝对内存位置无关的。想要生成对全局变量PIC引用的编译器利用了这个事实，它在数据段开始的地方创建了一个表，叫做全局偏移量表(Global Offset Table, GOT)。**在GOT中，每个被这个目标模块引用的全局数据目标(过程或全局变量)都有一个8字节条目**。**编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址**。**每个引用全局目标的目标模块都有自己的GOT**。



**PIC中的函数调用**：假设程序调用一个由共享库定义的函数。编译器没有办法预测这个函数的运行时地址，因为定义它的共享模块在运行时可以加载到任意位置。**正常的办法是为该引用生成一条重定位记录，然后动态链接器在程序加载的时候再解析它。不过这种方法并不是PIC，因为它需要链接器修改调用模块的代码段**。GNU编译系统使用了一个技术来解决这个问题，称为延迟绑定，将过程地址的绑定延迟到第一次调用该过程时。使用延迟绑定的动机是对于一个像libc.so这样的共享库输出的成百上千个函数中，一个典型的应用程序只会使用其中很少的一部分。**把函数地址的解析推迟到它实际被调用的地方，能避免动态链接器在加载时进行成百上千个其实并不需要的重定位。第一次调用过程的运行时开销很大，但是其后的每次调用都只会花费一条指令和一个间接的内存引用**。延时绑定是通过两个数据结构之间简洁但又有些复杂的交互来实现的，这两个数据结构是：GOT和过程链接表(Procedure Linkage Table, PLT)。**如果一个目标模块调用定义在共享库中的任何函数，那么它就有自己的GOT和PLT。GOT是数据段的一部分，而PLT是代码段的一部分**。

**PLT和GOT协作在运行时解析函数的地址**

* **过程链接表**：PLT是一个数组，其中每个条目是16字节的代码。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目都负责调用一个具体的函数。PLT[0]是一个特殊条目，它跳转到动态链接器中。PLT[1]调用系统启动函数(`__libc_start_main`)。从PLT[2]开始的条目调用用户代码调用的函数。
* **全局偏移量表**：GOT是一个数组，其中每个条目是8字节地址。GOT[0]是.dynamic的地址，GOT[1]是重定位条目的地址，GOT[2]是动态链接器在ld-linux.so模块中的入口点。其余的每个条目对应于一个被调用的函数，其地址需要在运行时被解析。每个条目都有一个相匹配的PLT条目。
* **解析过程**：以解析函数addvec为例
  * 不直接调用addvec，程序控制流进入addvec的PLT条目。
  * 







# 静态库

迄今为止，我们都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形成一个输出的可执行文件。实际上，**所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库，它可以用作链接器的输入**。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

几种方法的比较：

* **编译器识别对标准函数的调用**：编译器识别对标准函数的调用，并直接生成相应的代码。C标准定义了大量的标准函数，这种方法将给编译器增加显著的复杂性，而且每次添加、删除或修改一个标准函数时，都需要一个新的编译器版本。

* **一个单独的可重定位目标模块**：将所有的标准C函数都放在一个单独的可重定位目标模块中，应用程序员可以把这个模块链接到他们的可执行文件中。**这种方法的优点是它将编译器的实现与标准函数的实现分离开来**。一个很大的缺点是系统中的每个可执行文件现在都包含着一份标准函数集合的完全副本，这是对磁盘空间很大的浪费。更糟的是，每个正在运行的程序都将它自己的这些函数的副本放在内存中，这是对内存的极度浪费。另一个大的缺点是，对任何标准函数的任何改变，无论是多么小的改变，都要求库的开发人员重新编译整个源文件，这是一个非常耗时的操作，使得标准函数的开发和维护变的很复杂。

* **静态库**：为每个标准函数创建一个独立的可重定位文件，比如printf.o、scanf.o等。**相关的函数可以被编译为独立的目标模块，然后封装成一个独立的静态库文件**。在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字。**在Linux系统中，静态库以一种称为存档的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置**。存档文件名由后缀.a标识。















































