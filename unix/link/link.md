

加载器不会像它通常所做的那样将控制传递给应用，而是加载和运行这个动态连接器。然后，动态链接器执行下面的重定位完成链接任务：

* 重定位libc.so的文本和数据到某个内存段
* 重定位libvector.so的文本和数据到另一个内存段
* 重定位prog21中所有对由libc.so和libvector.so定义的符号的引用。

最后，动态链接器将控制传递给应用程序。从这个时刻开始，共享库的位置就固定了，并且在程序执行的过程中都不会改变。



# 静态库

迄今为止，我们都是假设链接器读取一组可重定位目标文件，并把它们链接起来，形成一个输出的可执行文件。实际上，**所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库，它可以用作链接器的输入**。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

几种方法的比较：

* **编译器识别对标准函数的调用**：编译器识别对标准函数的调用，并直接生成相应的代码。C标准定义了大量的标准函数，这种方法将给编译器增加显著的复杂性，而且每次添加、删除或修改一个标准函数时，都需要一个新的编译器版本。

* **一个单独的可重定位目标模块**：将所有的标准C函数都放在一个单独的可重定位目标模块中，应用程序员可以把这个模块链接到他们的可执行文件中。**这种方法的优点是它将编译器的实现与标准函数的实现分离开来**。一个很大的缺点是系统中的每个可执行文件现在都包含着一份标准函数集合的完全副本，这是对磁盘空间很大的浪费。更糟的是，每个正在运行的程序都将它自己的这些函数的副本放在内存中，这是对内存的极度浪费。另一个大的缺点是，对任何标准函数的任何改变，无论是多么小的改变，都要求库的开发人员重新编译整个源文件，这是一个非常耗时的操作，使得标准函数的开发和维护变的很复杂。

* **静态库**：为每个标准函数创建一个独立的可重定位文件，比如printf.o、scanf.o等。**相关的函数可以被编译为独立的目标模块，然后封装成一个独立的静态库文件**。在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。另一方面，应用程序员只需要包含较少的库文件的名字。**在Linux系统中，静态库以一种称为存档的特殊文件格式存放在磁盘中。存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置**。存档文件名由后缀.a标识。





# 从应用程序中加载和链接共享库













































